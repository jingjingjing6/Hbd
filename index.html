<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Birthday Animation - Fixed</title>
<style>
  :root{
    --bg:white;
    --text:#000;
    --bubble-bg:#ffffff;
    --bubble-bg-alt:#fff7a8;
    --bubble-color:#000;
    --landscape-w:1000px; /* internal landscape canvas target width */
    --landscape-h:562px;  /* internal landscape canvas height (16:9) */
  }
  html,body{
    height:100%;
    margin:0;
    background: #111;
    font-family: -apple-system, "Helvetica Neue", Arial, "Noto Sans SC", "PingFang SC", "Hiragino Sans GB", "Microsoft Yahei", sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  /* ---------- ROTATE SCREEN (portrait) ---------- */
  #rotateScreen{
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    background:#fff;
    color:#000;
    font-size:24px;
    text-align:center;
    padding:20px;
    box-sizing:border-box;
  }

  /* Stage wrapper that will be rotated to force landscape */
  #stage {
    display:none; /* will show after rotate screen */
    position:fixed;
    top:50%;
    left:50%;
    width:100vh;   /* swap w/h */
    height:100vw;
    transform: translate(-50%,-50%) rotate(90deg);
    transform-origin:center center;
    background:transparent;
    z-index:10;
    overflow:hidden;
  }

  /* internal landscape canvas: keep everything inside this */
  .landscape {
    width: calc(min(100vw, var(--landscape-w)));
    height: calc(min(100vh, var(--landscape-h)));
    background: white;
    position:relative;
    overflow:hidden;
    box-shadow: 0 6px 30px rgba(0,0,0,0.25);
    border-radius:6px;
    margin:auto;
    top:50%; left:50%;
    transform: translate(-50%,-50%);
  }

  .scene {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background: white;
    overflow:hidden;
  }

  .hidden { display:none!important; }

  /* ---------- image2 ---------- */
  #image2Wrap{
    background: white;
  }
  #image2 {
    position: absolute;
    left:50%;
    top:50%;
    width: auto;
    height: auto;
    max-width: 90%;
    max-height: 90%;
    object-fit: contain;     /* <-- ensure full image visible, no cropping */
    transform: translate(-50%, -50%) translate(-40%,40%);
    opacity:0;
    transition: transform 1.6s ease-in-out, opacity 1.6s ease-in-out;
    will-change:transform,opacity;
  }

  /* ---------- loading scene ---------- */
  #loadingScene{
    background: white;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
  }
  #loadingCanvas {
    position:relative;
    width:85%;
    height:55%;
    max-width:900px;
    max-height:360px;
    overflow:visible;
    display:block;
  }
  /* each tile uses image4.png */
  .pixel {
    position:absolute;
    width:22px;            /* default tile size (ÂèØË∞ÉÊï¥) */
    height:22px;
    background-image: url('image4.png');
    background-size:contain;
    background-repeat:no-repeat;
    opacity:0;
    transform: translateY(-8px);
    transition: opacity .18s linear, transform .18s ease;
    pointer-events:none;
  }
  #loadingTextLabel{
    margin-top:12px;
    font-size:22px; /* still display textual label, optional */
    color:#222;
    font-weight:600;
  }

  /* falling emojis */
  .emoji-fall {
    position:absolute;
    top:-40px;
    font-size:22px;
    pointer-events:none;
    animation-name:fall;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
  }
  @keyframes fall {
    to { transform: translateY(720px) rotate(360deg); opacity:0.05; }
  }

  /* image3 arrow on right vertical centered (within landscape) */
  #image3 {
    position:absolute;
    right:20px;
    top:50%;
    transform: translateY(-50%);
    opacity:0;
    transition: opacity .8s ease-in-out;
    max-width:80px;
    max-height:120px;
    pointer-events:none;
    z-index:6;
  }

  /* image1 background slide in */
  #image1bg {
    position:absolute;
    inset:0;
    background-size:cover;
    background-position:center center;
    transform: translateX(100%);
    transition: transform 1.6s ease-in-out;
    z-index:1;
  }

  /* message bubbles container */
  #bubbles {
    position:absolute;
    left:4%;
    width:56%;
    bottom:calc(100% / 3); /* start from lower two-thirds */
    display:flex;
    flex-direction:column;
    gap:12px;
    z-index:5;
    pointer-events:none;
  }
  .bubble {
    max-width:100%;
    display:inline-block;
    padding:12px 14px;
    border-radius:18px; /* ÂúÜËßí */
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
    opacity:0;
    transform: translateY(8px);
    transition: opacity .6s ease, transform .6s ease;
    word-break:break-word;
    font-size:15px;
    line-height:1.4;
  }
  .bubble.show {
    opacity:1;
    transform: translateY(0);
  }
  .bubble.white { background: var(--bubble-bg); color: var(--bubble-color); }
  .bubble.yellow { background: var(--bubble-bg-alt); color: var(--bubble-color); }

  /* final xD + rating screen (black) */
  #finalXDScreen {
    background:#000;
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    gap:14px;
    font-size:48px;
    z-index:9;
  }
  #pleaseRate {
    font-size:18px;
    margin-top:6px;
    display:none;
  }
  #stars {
    font-size:34px;
    letter-spacing:6px;
    cursor:pointer;
    user-select:none;
    display:none;
  }
  .star { display:inline-block; transform:translateY(0); transition: transform .12s ease; }
  .star:hover{ transform: translateY(-4px); }

  /* final thank you page */
  #thanksPage {
    background:#000;
    color:#fff;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
    padding:20px;
    box-sizing:border-box;
    font-size:20px;
    line-height:1.4;
    z-index:11;
  }

  /* mobile tweaks */
  @media (max-width:420px){
    .pixel{ width:16px; height:16px; }
    #loadingTextLabel{ font-size:18px; }
    #finalXDScreen { font-size:42px; }
    #stars { font-size:28px; }
  }
</style>
</head>
<body>

  <!-- PORTRAIT ROTATE SCREEN -->
  <div id="rotateScreen">
    <div style="max-width:90%;margin:auto;">
      <div style="font-size:28px;font-weight:700;color:#000;">please rotate your phoneüì±</div>
    </div>
  </div>

  <!-- LANDSCAPE STAGE (hidden initially) - this wrapper is rotated to force landscape view -->
  <div id="stage" aria-hidden="true">
    <div class="landscape" id="landscape">

      <!-- Step 2 image2 scene -->
      <div id="image2Wrap" class="scene" style="z-index:2;">
        <img id="image2" src="image2.jpg" alt="image2">
      </div>

      <!-- Loading scene -->
      <div id="loadingScene" class="scene hidden" style="z-index:3;">
        <div id="loadingCanvas" aria-hidden="false"></div>
        <div id="loadingTextLabel">loading...</div>
      </div>

      <!-- Arrow image3 (right side) -->
      <img id="image3" src="image3.png" alt="arrow" style="z-index:6;">

      <!-- image1 background (will slide in) -->
      <div id="image1bg" style="z-index:0; background-image:url('image1.jpg');"></div>

      <!-- bubbles -->
      <div id="bubbles" style="z-index:5;"></div>

      <!-- xD & rating overlay -->
      <div id="finalXDScreen" class="scene hidden" style="z-index:9;">
        <div id="xDText" style="font-weight:800;">xD</div>
        <div id="pleaseRate">please rate</div>
        <div id="stars" aria-label="rating">
          <span class="star" data-value="1">‚òÜ</span>
          <span class="star" data-value="2">‚òÜ</span>
          <span class="star" data-value="3">‚òÜ</span>
          <span class="star" data-value="4">‚òÜ</span>
          <span class="star" data-value="5">‚òÜ</span>
        </div>
      </div>

      <!-- final thanks page -->
      <div id="thanksPage" class="scene hidden" style="z-index:11;">
        <div style="white-space:pre-line; font-weight:600;">
thanks for your 5 star
Ôºàknew you would do this xD love you looots
        </div>
      </div>

    </div>
  </div>

<script>
/*
  ËØ¥ÊòéÔºö
  - Êää image1.jpg„ÄÅimage2.jpg„ÄÅimage3.png„ÄÅimage4.png ÊîæÂêå‰∏ÄÁõÆÂΩï‰∏ã
  - ‰∏ªË¶Å‰øÆÂ§çÁÇπÔºö
      1) image2 ‰ΩøÁî® object-fit: contain ‰øùËØÅÂÆåÊï¥ÊòæÁ§∫
      2) loading ‰ΩøÁî®Âü∫‰∫é canvas ÁöÑÁÇπÈòµÈááÊ†∑Ôºå‰ΩÜ tileSize Êõ¥Â§ßÔºå‰∏îÊØè‰∏™ÁÇπÁî® image4.png
         ‚Äî‚Äî ËøôÊ†∑ÊØè‰∏™Â≠óÁ¨¶ÊØèË°åÈÉΩ‰ºöÁî±Âçï‰∏™ image4 ÁªÑÊàêÁÇπÈòµÔºàÂèØË∞ÉÊï¥ tileSizeÔºâ
      3) rotate È°µÈù¢ÂêéÂº∫Âà∂Ê®™Â±èÔºöÈÄöËøá #stage wrapper ÊóãËΩ¨ÂÆûÁé∞
*/

(function(){
  // TIMINGS (ms)
  const T_ROTATE = 3000;
  const T_IMAGE2_TOTAL = 9000;
  const T_IMAGE2_FADE = 1600;
  const T_LOADING_PREP = 250;
  const PIXEL_APPEAR_INTERVAL = 18;
  const LOADING_DOT_REPEAT = 2;
  const EMOJI_FALL_COUNT = 12;
  const IMAGE3_SHOW = 2000;
  const IMAGE3_FADE = 800;
  const IMAGE1_SLIDE = 1600;
  const BUBBLE_INTERVAL = 5000; // each bubble shown then wait 5s
  const AFTER_LAST_BUBBLE_PAUSE = 8000;
  const XD_SHOW = 3000;
  const STARS_FINAL_REDIRECT_DELAY = 600;

  // messages
  const messages = [
    "Heyyy Ahmed, happy birthday to you!ü•≥",
    "If I could give you something today, it would be a quiet moment where nothing hurts and presses you",
    "I see how much you‚Äôre carrying, and I respect you for that!",
    "I hope this year brings you more ease so that you can breathe. ü´Ç",
    "Remember! You can always be yourself with me! Lots of love!ü•∞"
  ];

  // elements
  const rotateScreen = document.getElementById('rotateScreen');
  const stage = document.getElementById('stage');
  const landscape = document.getElementById('landscape');
  const image2 = document.getElementById('image2');
  const image2Wrap = document.getElementById('image2Wrap');
  const loadingScene = document.getElementById('loadingScene');
  const loadingCanvas = document.getElementById('loadingCanvas');
  const loadingLabel = document.getElementById('loadingTextLabel');
  const image3 = document.getElementById('image3');
  const image1bg = document.getElementById('image1bg');
  const bubblesWrap = document.getElementById('bubbles');
  const finalXDScreen = document.getElementById('finalXDScreen');
  const pleaseRate = document.getElementById('pleaseRate');
  const stars = document.getElementById('stars');
  const thanksPage = document.getElementById('thanksPage');

  const wait = ms => new Promise(r => setTimeout(r, ms));

  async function runSequence(){
    // 1. show portrait rotate screen
    rotateScreen.style.display = 'flex';
    stage.style.display = 'none';
    await wait(T_ROTATE);

    // hide rotate screen, show rotated stage (force landscape)
    rotateScreen.style.display = 'none';
    stage.style.display = 'block';
    stage.setAttribute('aria-hidden','false');

    // 2. image2 appear: set initial pos left-bottom and animate to center
    image2.style.opacity = '0';
    image2.style.transform = 'translate(-50%, -50%) translate(-40%,40%)';
    image2Wrap.classList.remove('hidden');

    // ensure image is loaded before animation (if large)
    await ensureImageLoaded(image2);

    // start transition
    await wait(60);
    image2.style.transition = `transform ${T_IMAGE2_FADE}ms cubic-bezier(.2,.9,.3,1), opacity ${T_IMAGE2_FADE}ms linear`;
    image2.style.transform = 'translate(-50%, -50%) translate(0,0)';
    image2.style.opacity = '1';

    await wait(T_IMAGE2_TOTAL);

    // fade out image2 and move to loading
    image2.style.opacity = '0';
    await wait(400);
    image2Wrap.classList.add('hidden');

    // 3. loading scene
    loadingScene.classList.remove('hidden');
    // add falling emojis
    addFallingEmojis();

    await wait(T_LOADING_PREP);

    // Build big dot-matrix for "loading..." using image4 tiles
    // tileSize controls density/size; choose larger so letters are clear
    await buildBigDotMatrix("loading", {
      fontSize: 180,   // big font to sample from (controls letter height)
      tileSize: 22,    // tile/image4 size in px (match CSS .pixel)
      step: 10,        // sampling step: smaller => denser dots
      dotRepeat: LOADING_DOT_REPEAT
    });

    // 4. show image3 for 2s
    await wait(400);
    image3.style.opacity = '1';
    await wait(IMAGE3_SHOW);
    image3.style.opacity = '0';
    await wait(IMAGE3_FADE);

    // 5. slide image1 as background
    loadingScene.classList.add('hidden');
    image1bg.style.transform = 'translateX(0)';
    await wait(IMAGE1_SLIDE + 200);

    // show bubbles one by one
    await showBubbles();

    // after last bubble wait long pause
    await wait(AFTER_LAST_BUBBLE_PAUSE);

    // show xD
    finalXDScreen.classList.remove('hidden');
    await wait(XD_SHOW);

    // show rating UI
    pleaseRate.style.display = 'block';
    stars.style.display = 'block';
    attachStarHandlers();
  }

  // ensure image loaded
  function ensureImageLoaded(img){
    return new Promise(resolve=>{
      if(img.complete && img.naturalWidth !== 0) return resolve();
      img.onload = () => resolve();
      img.onerror = () => resolve(); // continue anyway
    });
  }

  // add falling emojis in loadingScene
  function addFallingEmojis(){
    const emojis = ["üéÇ","üßÅ","‚≠ê","üíõ"];
    for(let i=0;i<EMOJI_FALL_COUNT;i++){
      const el = document.createElement('div');
      el.className = 'emoji-fall';
      el.textContent = emojis[i % emojis.length];
      el.style.left = (5 + Math.random() * 90) + '%';
      const dur = 3500 + Math.round(Math.random()*3000);
      el.style.animationDuration = dur + 'ms';
      el.style.animationDelay = (i*180) + 'ms';
      el.style.opacity = '0.95';
      loadingScene.appendChild(el);
    }
  }

  // Build big dot matrix by rendering text on a canvas and sampling pixels.
  // For each sampled "on" pixel we create a .pixel (image4) element positioned in loadingCanvas.
  // After initial reveal we animate the trailing dots "..." cycles LOADING_DOT_REPEAT times then leave them visible.
  async function buildBigDotMatrix(text, opts){
    const fontSize = opts.fontSize || 160;
    const tileSize = opts.tileSize || 22;
    const step = opts.step || Math.max(8, Math.floor(tileSize/1.5));
    const dotRepeat = opts.dotRepeat || 2;

    // create canvas and size based on text dimensions
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.font = `bold ${fontSize}px sans-serif`;
    const textWidth = Math.ceil(ctx.measureText(text + "...").width);
    const textHeight = Math.ceil(fontSize * 1.1);
    canvas.width = textWidth + 40;
    canvas.height = textHeight + 40;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#000';
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.textBaseline = 'top';
    ctx.fillText(text + "...", 20, 10);

    // sample pixels
    const imgd = ctx.getImageData(0,0,canvas.width,canvas.height);
    const pixels = [];
    for(let y=0;y<canvas.height;y+=step){
      for(let x=0;x<canvas.width;x+=step){
        const idx = (y*canvas.width + x) * 4;
        if(imgd.data[idx+3] > 140){ // alpha threshold
          pixels.push({x,y});
        }
      }
    }

    // compute scale to place inside loadingCanvas
    loadingCanvas.innerHTML = '';
    const bounds = loadingCanvas.getBoundingClientRect();
    const scale = Math.min(bounds.width / canvas.width, bounds.height / canvas.height);
    const offsetX = (bounds.width - canvas.width * scale) / 2;
    const offsetY = (bounds.height - canvas.height * scale) / 2;

    // create pixel elements; show them sequentially top->bottom left->right
    pixels.sort((a,b) => a.y - b.y || a.x - b.x);
    const maxDots = pixels.length;
    for(let i=0;i<maxDots;i++){
      const p = pixels[i];
      const el = document.createElement('div');
      el.className = 'pixel';
      el.style.width = tileSize + 'px';
      el.style.height = tileSize + 'px';
      el.style.left = (offsetX + p.x * scale) + 'px';
      el.style.top = (offsetY + p.y * scale) + 'px';
      loadingCanvas.appendChild(el);
      // animate appear
      setTimeout(()=>{
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
      }, i * PIXEL_APPEAR_INTERVAL);
    }

    // find positions for trailing dots (the canvas text had "..." after word). We'll detect rightmost three clusters.
    // Determine approximate positions: measure where "..." started
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillText(text, 20, 10);
    const textW = ctx.measureText(text).width;
    const dotsStartX = 20 + textW + 8;
    // create three larger dot placeholders
    const dotEls = [];
    for(let i=0;i<3;i++){
      const el = document.createElement('div');
      el.className = 'pixel';
      el.style.width = (tileSize + 4) + 'px';
      el.style.height = (tileSize + 4) + 'px';
      el.style.left = (offsetX + (dotsStartX + i * (tileSize + 6)) * scale) + 'px';
      el.style.top = (offsetY + (10 + fontSize/2 - tileSize/2) * scale) + 'px';
      el.style.opacity = '0';
      loadingCanvas.appendChild(el);
      dotEls.push(el);
    }

    // cycle animation for trailing dots
    await new Promise(resolve => {
      let cycles = 0;
      const total = dotRepeat;
      const baseDelay = Math.max(300, maxDots * PIXEL_APPEAR_INTERVAL + 80);
      const cycle = () => {
        // show sequentially
        dotEls.forEach((el, idx) => {
          setTimeout(()=> { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; }, baseDelay + idx * 280);
        });
        // hide after a bit
        setTimeout(()=> {
          dotEls.forEach(el => { el.style.opacity = '0'; });
        }, baseDelay + 3*280 + 200);

        cycles++;
        if(cycles < total){
          setTimeout(cycle, baseDelay + 3*280 + 380);
        } else {
          // final show and fix them visible
          setTimeout(()=> {
            dotEls.forEach((el, idx)=> {
              setTimeout(()=> { el.style.opacity = '1'; }, idx*100);
            });
            setTimeout(resolve, 600);
          }, baseDelay + 3*280 + 200);
        }
      };
      // start after initial pixel animation done
      setTimeout(cycle, Math.max(300, maxDots * PIXEL_APPEAR_INTERVAL + 60));
    });

    return;
  }

  // show bubbles sequentially
  async function showBubbles(){
    bubblesWrap.innerHTML = '';
    for(let i=0;i<messages.length;i++){
      const el = document.createElement('div');
      el.className = 'bubble ' + ((i%2===0)?'white':'yellow');
      el.textContent = messages[i];
      bubblesWrap.appendChild(el);
      await wait(120);
      el.classList.add('show');
      await wait(BUBBLE_INTERVAL); // wait after each bubble
    }
  }

  // stars handlers
  function attachStarHandlers(){
    const starEls = Array.from(document.querySelectorAll('#stars .star'));
    starEls.forEach(s => {
      s.addEventListener('click', () => {
        const val = parseInt(s.dataset.value || '1', 10);
        fillStars(val);
        if(val === 5){
          setTimeout(()=> {
            finalXDScreen.classList.add('hidden');
            thanksPage.classList.remove('hidden');
            thanksPage.style.display = 'flex';
          }, STARS_FINAL_REDIRECT_DELAY);
        }
      });
      s.addEventListener('mouseover', () => {
        const v = parseInt(s.dataset.value,10);
        fillStars(v);
      });
      s.addEventListener('mouseout', () => {
        const filled = document.querySelectorAll('#stars .star.filled').length;
        fillStars(filled);
      });
    });
  }
  function fillStars(count){
    const starEls = Array.from(document.querySelectorAll('#stars .star'));
    starEls.forEach((st, idx) => {
      if(idx < count){
        st.textContent = '‚≠ê';
        st.classList.add('filled');
      } else {
        st.textContent = '‚òÜ';
        st.classList.remove('filled');
      }
    });
  }

  // kick off
  runSequence();

  // safety
  window.addEventListener('error', (e)=> { console.warn('Resource error:', e); });
})();
</script>

</body>
</html>
